#include "Win32Mouse.hpp"

#include <Usagi/Runtime/Input/Mouse/MouseEventListener.hpp>
#include <Usagi/Extension/Win32/Window/Win32WindowManager.hpp>
#include <Usagi/Extension/Win32/Window/Win32Window.hpp>

// Microsoft forgot to define it for Windows 8.1
#ifndef RI_MOUSE_HWHEEL
#define RI_MOUSE_HWHEEL 0x0800
#endif

void usagi::Win32Mouse::sendButtonEvent(
    Window *window,
    MouseButtonCode button,
    const bool pressed,
    const Vector2f &pos)
{
    auto &prev_pressed = mMouseButtonDown[static_cast<std::size_t>(button)];

    // if we receive an release event without a prior press event, it means that
    // the user activated our window by clicking. this is only meaningful if we
    // are in normal mode when using GUI. if immersive mode is enabled, such
    // event may cause undesired behavior, such as firing the weapon.
    if(!pressed && !prev_pressed && isImmersiveMode())
        return;

    prev_pressed = pressed;

    MouseButtonEvent e;
    e.mouse = this;
    e.window = window;
    e.position = pos;
    e.button = button;
    e.pressed = pressed;
    forEachListener([&](auto h) {
        h->onMouseButtonStateChange(e);
    });
}

void usagi::Win32Mouse::sendWheelEvent(
    Window *window,
    const Vector2f &distance,
    const Vector2f &pos)
{
    MouseWheelEvent e;
    e.mouse = this;
    e.window = window;
    e.position = pos;
    e.distance = distance;
    forEachListener([&](auto h) {
        h->onMouseWheelScroll(e);
    });
}

void usagi::Win32Mouse::recaptureCursor()
{
    if(mMouseCursorCaptured) captureCursor();
}

void usagi::Win32Mouse::confineCursorInClientArea()
{
    const auto client_rect =
        Win32WindowManager::activeWindow()->clientScreenRect();
    ClipCursor(&client_rect);
}

void usagi::Win32Mouse::handleRawInput(RAWINPUT *raw)
{
    checkDevice(raw, RIM_TYPEMOUSE);

    // ignore the message if no window is active.
    const auto window = Win32WindowManager::activeWindow();
    if(!window) return;

    auto &mouse = raw->data.mouse;
    Vector2f abs, rel;

    // if the mouse position is absolute (e.g. sent by remote desktop software)
    // convert them to relative. note that typically only relative positions
    // are generated by windows.
    // see https://stackoverflow.com/questions/14113303/raw-input-device-rawmouse-usage
    if(mouse.usFlags & MOUSE_MOVE_ABSOLUTE)
    {
        assert(mouse.usFlags & MOUSE_VIRTUAL_DESKTOP);

        // when using remote desktop, the coordinates of mouse cursor ranges
        // from 0~65535 which covers the screen, a conversion using screen
        // size is therefore required.
        // see http://www.petergiuntoli.com/parsing-wm_input-over-remote-desktop
        // and https://stackoverflow.com/questions/31949476/raw-input-mouse-lastx-lasty-with-odd-values-while-logged-in-through-rdp
        abs = screenPositionToActiveWindow(
            convertFromVirtualDesktopPosition({ mouse.lLastX, mouse.lLastY })
        );
        // todo the rel pos will be wrong after switching to another window
        rel = abs - mLastPosition;
    }
    else
    {
        abs = cursorPositionInActiveWindow();
        rel = { mouse.lLastX, mouse.lLastY };
    }
    mLastPosition = abs;

    // when in GUI mode, only processes events inside the window rect
    // todo since we use raw input, we receive the mouse messages even if the
    // part of window is covered, in which case the user might perform
    // undesired actions.
    if(!isImmersiveMode())
    {
        const auto win_size = window->size();
        // todo process the input if any mouse button is pressed (dragging)
        if(abs.x() < 0 || abs.y() < 0 ||
            abs.x() >= win_size.x() || abs.y() >= win_size.y())
            return;
    }

    // process mouse movement
    if(!rel.isZero())
    {
        MousePositionEvent e;
        e.mouse = this;
        e.window = window;
        // todo absolute position of the event
        e.position = abs;
        e.distance = rel;
        forEachListener([&](auto h) {
            h->onMouseMove(e);
        });
    }
    // process mouse buttons & scrolling
    if(mouse.usButtonFlags)
    {
        // process mouse buttons
        // note that it is impossible to activate another window while holding
        // a mouse button pressed within the active window, so it is
        // unnecessary to clear button press states when deactivate the window.
        // however this is not the case for the keyboard.
#define MOUSE_BTN_EVENT(native_code, code) \
        if(mouse.usButtonFlags & RI_MOUSE_##native_code##_DOWN) \
            sendButtonEvent(window, MouseButtonCode::code, true, abs); \
        else if(mouse.usButtonFlags & RI_MOUSE_##native_code##_UP) \
            sendButtonEvent(window, MouseButtonCode::code, false, abs) \
/**/
        MOUSE_BTN_EVENT(LEFT_BUTTON, LEFT);
        MOUSE_BTN_EVENT(MIDDLE_BUTTON, MIDDLE);
        MOUSE_BTN_EVENT(RIGHT_BUTTON, RIGHT);
        MOUSE_BTN_EVENT(BUTTON_4, BUTTON_4);
        MOUSE_BTN_EVENT(BUTTON_5, BUTTON_5);
#undef MOUSE_BTN_EVENT

        // process scrolling
        if(mouse.usButtonFlags & RI_MOUSE_WHEEL)
            sendWheelEvent(window, {
                0, static_cast<short>(mouse.usButtonData) / WHEEL_DELTA
            }, abs);
        // horizontal scrolling, which seems to be undocumented.
        // found here: https://stackoverflow.com/questions/7942307/horizontal-mouse-wheel-messages-from-windows-raw-input
        if(mouse.usButtonFlags & RI_MOUSE_HWHEEL)
            sendWheelEvent(window, {
                static_cast<short>(mouse.usButtonData) / WHEEL_DELTA, 0
            }, abs);
    }
}

POINT usagi::Win32Mouse::convertFromVirtualDesktopPosition(
    const Vector2f &pos)
{
    const auto width = static_cast<float>(GetSystemMetrics(SM_CXVIRTUALSCREEN));
    const auto height = static_cast<float>(GetSystemMetrics(SM_CYVIRTUALSCREEN));
    return {
        static_cast<LONG>(pos.x() / USHRT_MAX * width),
        static_cast<LONG>(pos.y() / USHRT_MAX * height)
    };
}

usagi::Win32Mouse::Win32Mouse(
    const HANDLE device_handle,
    std::string name)
    : Win32RawInputDevice { device_handle, std::move(name) }
{
}

void usagi::Win32Mouse::onWindowFocusChanged(const WindowFocusEvent &e)
{
    // note that Windows uses a counter to decide whether to show the cursor,
    // so the amount of show/hide operations must match.
    // See: https://blogs.msdn.microsoft.com/oldnewthing/20091217-00/?p=15643
    if(e.focused)
    {
        recaptureCursor();
        if(!mShowMouseCursor)
            ShowCursor(false);
    }
    else
    {
        if(mMouseCursorCaptured) // temporarily release the cursor
            ClipCursor(nullptr);
        if(!mShowMouseCursor)
            ShowCursor(true);
    }
}

void usagi::Win32Mouse::onWindowMoveEnd(const WindowPositionEvent &e)
{
    recaptureCursor();
}

void usagi::Win32Mouse::onWindowResizeEnd(const WindowSizeEvent &e)
{
    recaptureCursor();
}

std::string usagi::Win32Mouse::name() const
{
    return mName;
}

usagi::Vector2f usagi::Win32Mouse::screenPositionToActiveWindow(POINT screen)
{
    if(const auto wnd = Win32WindowManager::activeWindow())
    {
        ScreenToClient(wnd->handle(), &screen);
        return { screen.x, screen.y };
    }
    return Vector2f::Zero();
}

usagi::Vector2f usagi::Win32Mouse::cursorPositionInActiveWindow()
{
    POINT pt;
    GetCursorPos(&pt);
    return screenPositionToActiveWindow(pt);
}

void usagi::Win32Mouse::centerCursor()
{
    if(const auto wnd = Win32WindowManager::activeWindow())
    {
        const auto rect = wnd->clientScreenRect();
        Vector2i cursor{
            (rect.left + rect.right) / 2,
            (rect.top + rect.bottom) / 2
        };
        SetCursorPos(cursor.x(), cursor.y());
    }
}

void usagi::Win32Mouse::showCursor(bool show)
{
    if(mShowMouseCursor == show) return;

    ShowCursor(show);
    mShowMouseCursor = show;
}

bool usagi::Win32Mouse::isButtonPressed(MouseButtonCode button) const
{
    const auto idx = static_cast<std::size_t>(button);
    if(idx > sizeof(mMouseButtonDown) / sizeof(bool)) return false;
    return mMouseButtonDown[idx];
}

void usagi::Win32Mouse::captureCursor()
{
    confineCursorInClientArea();
    mMouseCursorCaptured = true;
}

void usagi::Win32Mouse::releaseCursor()
{
    // remove cursor restriction
    ClipCursor(nullptr);
    mMouseCursorCaptured = false;
}

bool usagi::Win32Mouse::isCursorCaptured()
{
    return mMouseCursorCaptured;
}
